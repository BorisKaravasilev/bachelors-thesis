using System.Collections.Generic;
using UnityEngine;
using Vector2 = UnityEngine.Vector2;
using Vector3 = UnityEngine.Vector3;

namespace ObjectPlacement.JitteredGrid
{
	/// <summary>
	/// Generates points on a square grid and offsets them by noise.
	/// </summary>
	public class JitteredGrid<TNoise2D>
		where TNoise2D : Noise2D, new()
	{
		private GridParams gridParams;
		private OffsetParams offsetParams;

		TNoise2D xOffsetNoise;
		TNoise2D zOffsetNoise;
		TNoise2D thresholdNoise;

		private List<GridPoint> points;

		private BoundingBox3D lastBoundingBox;

		/// <summary>
		/// Initialization from settings.
		/// </summary>
		public JitteredGrid(GridParams gridParams, OffsetParams offsetParams)
		{
			this.gridParams = gridParams;
			this.offsetParams = offsetParams;

			points = new List<GridPoint>();

			xOffsetNoise = new TNoise2D();
			zOffsetNoise = new TNoise2D();
			thresholdNoise = new TNoise2D();

			xOffsetNoise.SetParameters(offsetParams.XOffsetParams);
			zOffsetNoise.SetParameters(offsetParams.ZOffsetParams);
			thresholdNoise.SetParameters(offsetParams.ThresholdParams);
		}

		/// <summary>
		/// Generates points within the bounding box, may remove the points outside of it depending on the settings.
		/// </summary>
		/// <returns>Newly generated points.</returns>
		public List<GridPoint> GetPointsInBoundingBox(BoundingBox3D boundingBox)
		{
			List<GridPoint> newlyGenerated = GeneratePoints(boundingBox);
			if (gridParams.DestroyFarPoints) RemovePointsOutOfRange(boundingBox);
			lastBoundingBox = boundingBox;
			return newlyGenerated;
		}

		/// <summary>
		/// Updates the grid's parameters and removes all previously generated points.
		/// </summary>
		public void UpdateParameters(GridParams newGridParams, OffsetParams newOffsetParams)
		{
			gridParams = newGridParams;
			offsetParams = newOffsetParams;

			points.Clear();
		}

		/// <summary>
		/// Returns a list of all points generated by the object grid in the last specified bounding box.
		/// </summary>
		public List<GridPoint> GetPoints()
		{
			return points;
		}

		#region Private Methods

		/// <summary>
		/// Generates points on a grid and returns the newly instantiated ones.
		/// </summary>
		private List<GridPoint> GeneratePoints(BoundingBox3D boundingBox)
		{
			List<GridPoint> newlyInstantiated = new List<GridPoint>();

			Vector3 bottomLeftGridPoint = FindBottomLeftPointPosition(boundingBox);

			int minX = (int)bottomLeftGridPoint.x;
			int minZ = (int)bottomLeftGridPoint.z;

			int maxX = Mathf.FloorToInt(boundingBox.TopRight.x);
			int maxZ = Mathf.FloorToInt(boundingBox.TopRight.z);

			for (int z = minZ; z <= maxZ; z += gridParams.Spacing)
			{
				for (int x = minX; x <= maxX; x += gridParams.Spacing)
				{
					if (PointCountLimitReached()) return newlyInstantiated;

					Vector3 onGridPosition = new Vector3(x, 0f, z);
					Vector3 offsetPosition = OffsetPositionByNoise(onGridPosition);
					GridPoint newGridPoint = CreateNewPoint(onGridPosition, offsetPosition);

					if (newGridPoint != null)
					{
						points.Add(newGridPoint);
						newlyInstantiated.Add(newGridPoint);
					}
				}
			}

			return newlyInstantiated;
		}

		/// <summary>
		/// Creates a new grid points and calculates it's maximum radius depending on its offset.
		/// </summary>
		private GridPoint CreateNewPoint(Vector3 onGridPosition, Vector3 offsetPosition)
		{
			if (!IsPointGenerated(offsetPosition) && IsPointAboveThreshold(offsetPosition))
			{
				float maxRadius = GetPointMaxRadius(onGridPosition, offsetPosition);
				return new GridPoint(offsetPosition, maxRadius);
			}

			return null;
		}

		/// <summary>
		/// Checks if maximum generated points limit has been reached.
		/// </summary>
		private bool PointCountLimitReached()
		{
			if (points.Count >= gridParams.PointCountLimit)
			{
				Debug.LogWarning("Reached limit of " + gridParams.PointCountLimit + " generated grid points.");
				return true;
			}
			else
			{
				return false;
			}
		}

		/// <summary>
		/// Calculates the maximum radius of a point without a collision with other points.
		/// </summary>
		private float GetPointMaxRadius(Vector3 onGridPosition, Vector3 offsetPosition)
		{
			float offsetAmount = Vector3.Distance(onGridPosition, offsetPosition);
			float maxRadius = gridParams.Spacing / 2f - offsetAmount;

			return maxRadius;
		}

		/// <summary>
		/// Removes the points outside of the bounding box.
		/// </summary>
		private void RemovePointsOutOfRange(BoundingBox3D boundingBox)
		{
			List<GridPoint> pointsToRemove = new List<GridPoint>();

			foreach (GridPoint point in points)
			{
				if (!boundingBox.EnclosesInXZ(point.Position))
				{
					pointsToRemove.Add(point);
				}
			}

			RemovePointsFromList(pointsToRemove);
		}

		private void RemovePointsFromList(List<GridPoint> pointsToRemove)
		{
			foreach (GridPoint point in pointsToRemove)
			{
				points.Remove(point);
			}
		}

		/// <summary>
		/// Finds the left most bottom most point on the grid within the bounding box.
		/// </summary>
		private Vector3 FindBottomLeftPointPosition(BoundingBox3D boundingBox)
		{
			int pointMinX = Mathf.CeilToInt(boundingBox.BottomLeft.x);
			int pointMinZ = Mathf.CeilToInt(boundingBox.BottomLeft.z);

			int xDistanceToGridPoint = pointMinX % gridParams.Spacing;
			int mostLeftXOnGridInBounds = pointMinX - xDistanceToGridPoint;

			int zDistanceToGridPoint = pointMinZ % gridParams.Spacing;
			int lowestZOnGridInBounds = pointMinZ - zDistanceToGridPoint;

			return new Vector3(mostLeftXOnGridInBounds, 0f, lowestZOnGridInBounds);
		}

		/// <summary>
		/// Checks if point is already generated at the given position.
		/// </summary>
		private bool IsPointGenerated(Vector3 checkedPosition)
		{
			bool isGenerated = false;

			foreach (GridPoint point in points)
			{
				if (point.Position == checkedPosition)
				{
					isGenerated = true;
					break;
				}
			}

			return isGenerated;
		}

		/// <summary>
		/// Offsets a point in X and Z axis by two separate instances of noise.
		/// </summary>
		private Vector3 OffsetPositionByNoise(Vector3 position)
		{
			Vector2 noiseCoordinates = new Vector2(position.x, position.z);

			// Noise returns values 0-1
			// - subtracting 0.5 from it shifts the range -0.5 - 0.5
			// - multiplying by 2 extends the range to -1 - 1
			// - multiplying by max. offset shifts the value to the range of -maxObjectOffset - maxObjectOffset
			float limitedMaxOffset = offsetParams.MaxOffset;

			if (limitedMaxOffset > gridParams.Spacing * 0.4f)
			{
				limitedMaxOffset = gridParams.Spacing * 0.4f;
			}

			float offsetX = (xOffsetNoise.GetValue(noiseCoordinates) - 0.5f) * 2f * limitedMaxOffset;
			float offsetZ = (zOffsetNoise.GetValue(noiseCoordinates) - 0.5f) * 2f * limitedMaxOffset;

			Vector3 newPosition = new Vector3();

			newPosition.x = position.x + offsetX;
			newPosition.y = position.y;
			newPosition.z = position.z + offsetZ;

			return newPosition;
		}

		/// <summary>
		/// Checks if the value of the noise at the given position if is above the threshold.
		/// </summary>
		private bool IsPointAboveThreshold(Vector3 position)
		{
			Vector2 noiseCoordinates = new Vector2(position.x, position.z);
			return thresholdNoise.GetValue(noiseCoordinates) >= offsetParams.Threshold;
		}

		#endregion
	}
}